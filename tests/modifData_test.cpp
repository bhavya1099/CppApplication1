// ********RoostGPT********
// Test generated by RoostGPT for test cppTest using AI Type  and AI Model 



// ********RoostGPT********
#include <gtest/gtest.h>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include "Boulde_ES_MX.h" // Assuming this contains the dialog strings

// Function prototype
int modifData(char mode, int *money, int *lvl, int *exp, int *inventory, int inventory_S);

class ModifDataTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Create a temporary file for testing
        std::tmpnam(temp_filename);
    }

    void TearDown() override {
        // Remove the temporary file
        std::remove(temp_filename);
    }

    char temp_filename[L_tmpnam];
};

// Positive test case: Save data
TEST_F(ModifDataTest, SaveDataSuccessfully) {
    int money = 100, lvl = 5, exp = 1000;
    int inventory[3] = {1, 2, 3};
    
    // Redirect stdout to capture output
    testing::internal::CaptureStdout();
    
    EXPECT_EQ(0, modifData('s', &money, &lvl, &exp, inventory, 3));
    
    std::string output = testing::internal::GetCapturedStdout();
    EXPECT_STREQ(savedDataDlg, output.c_str());

    // Verify file contents
    FILE* file = fopen("player.esav", "rb");
    ASSERT_NE(nullptr, file);
    
    int read_money, read_lvl, read_exp;
    int read_inventory[3];
    
    EXPECT_EQ(1, fread(&read_money, sizeof(int), 1, file));
    EXPECT_EQ(1, fread(&read_lvl, sizeof(int), 1, file));
    EXPECT_EQ(1, fread(&read_exp, sizeof(int), 1, file));
    EXPECT_EQ(3, fread(read_inventory, sizeof(int), 3, file));
    
    EXPECT_EQ(money, read_money);
    EXPECT_EQ(lvl, read_lvl);
    EXPECT_EQ(exp, read_exp);
    EXPECT_EQ(0, memcmp(inventory, read_inventory, sizeof(int) * 3));
    
    fclose(file);
}

// Positive test case: Load data
TEST_F(ModifDataTest, LoadDataSuccessfully) {
    int money = 200, lvl = 10, exp = 2000;
    int inventory[3] = {4, 5, 6};
    
    // First, save some data
    ASSERT_EQ(0, modifData('s', &money, &lvl, &exp, inventory, 3));
    
    // Now, load the data
    int load_money = 0, load_lvl = 0, load_exp = 0;
    int load_inventory[3] = {0};
    
    testing::internal::CaptureStdout();
    
    EXPECT_EQ(0, modifData('l', &load_money, &load_lvl, &load_exp, load_inventory, 3));
    
    std::string output = testing::internal::GetCapturedStdout();
    EXPECT_STREQ(loadedDataDlg, output.c_str());
    
    EXPECT_EQ(money, load_money);
    EXPECT_EQ(lvl, load_lvl);
    EXPECT_EQ(exp, load_exp);
    EXPECT_EQ(0, memcmp(inventory, load_inventory, sizeof(int) * 3));
}

// Negative test case: Invalid mode
TEST_F(ModifDataTest, InvalidMode) {
    int money = 100, lvl = 5, exp = 1000;
    int inventory[3] = {1, 2, 3};
    
    EXPECT_EQ(0, modifData('x', &money, &lvl, &exp, inventory, 3));
}

// Negative test case: File not found (for load)
TEST_F(ModifDataTest, LoadNonExistentFile) {
    int money = 0, lvl = 0, exp = 0;
    int inventory[3] = {0};
    
    // Remove the file if it exists
    std::remove("player.esav");
    
    EXPECT_THROW(modifData('l', &money, &lvl, &exp, inventory, 3), std::runtime_error);
}

// Edge case: Reset data with "yes" confirmation
TEST_F(ModifDataTest, ResetDataWithConfirmation) {
    // Simulate user input
    FILE* input = fmemopen((void*)"yes", 3, "r");
    stdin = input;
    
    int money = 100, lvl = 5, exp = 1000;
    int inventory[3] = {1, 2, 3};
    
    testing::internal::CaptureStdout();
    
    EXPECT_EQ(1, modifData('r', &money, &lvl, &exp, inventory, 3));
    
    std::string output = testing::internal::GetCapturedStdout();
    EXPECT_STREQ(resetingDlg, output.c_str());
    
    fclose(input);
    stdin = nullptr;
    
    // Verify reset data
    FILE* file = fopen("player.esav", "rb");
    ASSERT_NE(nullptr, file);
    
    int read_money, read_lvl, read_exp;
    int read_inventory[3];
    
    EXPECT_EQ(1, fread(&read_money, sizeof(int), 1, file));
    EXPECT_EQ(1, fread(&read_lvl, sizeof(int), 1, file));
    EXPECT_EQ(1, fread(&read_exp, sizeof(int), 1, file));
    EXPECT_EQ(3, fread(read_inventory, sizeof(int), 3, file));
    
    EXPECT_EQ(10, read_money);
    EXPECT_EQ(1, read_lvl);
    EXPECT_EQ(0, read_exp);
    EXPECT_EQ(0, read_inventory[0]);
    EXPECT_EQ(-1, read_inventory[1]);
    EXPECT_EQ(-1, read_inventory[2]);
    
    fclose(file);
}

// Edge case: Reset data with "no" confirmation
TEST_F(ModifDataTest, ResetDataWithoutConfirmation) {
    // Simulate user input
    FILE* input = fmemopen((void*)"no", 2, "r");
    stdin = input;
    
    int money = 100, lvl = 5, exp = 1000;
    int inventory[3] = {1, 2, 3};
    
    testing::internal::CaptureStdout();
    
    EXPECT_EQ(0, modifData('r', &money, &lvl, &exp, inventory, 3));
    
    std::string output = testing::internal::GetCapturedStdout();
    EXPECT_STREQ(cancelledDlg, output.c_str());
    
    fclose(input);
    stdin = nullptr;
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
